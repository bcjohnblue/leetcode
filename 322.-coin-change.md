# 322. Coin Change

### Leetcode

[https://leetcode.com/problems/coin-change/description/](https://leetcode.com/problems/coin-change/description/)

### 題目

You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.

Return _the fewest number of coins that you need to make up that amount_. If that amount of money cannot be made up by any combination of the coins, return `-1`.

You may assume that you have an infinite number of each kind of coin.

&#x20;

**Example 1:**

<pre><code><strong>Input: coins = [1,2,5], amount = 11
</strong><strong>Output: 3
</strong><strong>Explanation: 11 = 5 + 5 + 1
</strong></code></pre>

**Example 2:**

<pre><code><strong>Input: coins = [2], amount = 3
</strong><strong>Output: -1
</strong></code></pre>

**Example 3:**

<pre><code><strong>Input: coins = [1], amount = 0
</strong><strong>Output: 0
</strong></code></pre>

### 解答 <a href="#ti-jie" id="ti-jie"></a>

* **方法一**

一開始的想法是將 `amount` 當做 DP 不斷累加的對象

範例：`coins = [1, 6, 7, 11],`` ``amount = 13`

一開始設初始值 `dp = [0]`，`dp[index]` 代表擲到 index 數字所需的最小次數，`dp[0]` 意思是擲到 0 所需的次數為零 (不需要擲)，接著從 1  遍歷到 amount: 13，計算每一輪中擲出 amount 的最低次數：

`amount: 1` 時，直接取第一個元素即可，最低次數為 1 => `dp = [0, 1]`

`amount: 2` 時，最低次數會是 `dp[1] + dp[1]`，代表擲出兩次 1

最低次數為 2  => `dp = [0, 1, 2]`

`amount: 3` 時，最低次數會是 `dp[2] + dp[1]`，代表擲出三次 1

最低次數為 3  => `dp = [0, 1, 2, 3]`

...

`amount: 6` 時，直接取第二個元素，代表擲出一次 6 => `dp[6] = 1`

`amount: 7` 時，直接取第三個元素，代表擲出一次 7 => `dp[7] = 1`

...

`amount: 13` 時，最低次數有可能會是：

先看 `coins` 中有沒有 13，有的話那就代表擲出一次 13 即可 => `dp[13] = 1`

接著最低次數的判斷可以根據之前計算出來的 DP 結果找出來：

* `dp[1] + dp[12]`  => 代表擲出 1 的最低次數 + 擲出 12 的最低次數
* `dp[2] + dp[11]` => 代表擲出 2 的最低次數 + 擲出 11 的最低次數
* ...
* `dp[6] + dp[7]` => 代表擲出 6 的最低次數 + 擲出 7 的最低次數

最後發現 `dp[6] + dp[7]` 是最低的擲出次數 2 => 所以 `dp[13] = 2`，代表擲出 13 的最低次數為 2

```javascript
var coinChange = function (coins, amount) {
    if (amount === 0) return 0;

    const dp = [0];

    for (let i = 1; i <= amount; i++) {
        const target = coins.find(coin => coin === i);
        if (target) {
            // 元素存在，擲一次就可以
            dp[i] = 1;
        } else {
            // 如果元素不存在，先把 dp[i] 設為最大值
            dp[i] = Number.MAX_SAFE_INTEGER;
            let match = false;
            // 遍歷前面 dp 的可能性
            for (let j = 1; j <= Math.floor(i / 2); j++) {
                if (dp[j] !== -1 && dp[i - j] !== -1) {
                    // 遍歷前面 dp 的可能性，找出最小擲出的次數
                    dp[i] = Math.min(dp[i], dp[j] + dp[i - j]);
                    match = true;
                }
            }
            
            // 怎麼擲都擲不出來的狀況設為 -1
            if (!match) {
                dp[i] = -1;
            }
        }
    }

    return dp[amount];
};
```

但這個方法會從 1 一路算到 amount，並且每一輪中還要遍歷原有的 dp 找出最小值，所以很明顯會 TLE



### 參考資料
